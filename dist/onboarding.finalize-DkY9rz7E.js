import "./paths-B4BZAPZh.js";
import { h as pathExists, y as resolveUserPath } from "./utils-DNXtLoeA.js";
import "./thinking-EAliFiVK.js";
import "./reply-BWrYqT-C.js";
import { v as DEFAULT_BOOTSTRAP_FILENAME } from "./agent-scope-s4_jffYt.js";
import { p as restoreTerminalState } from "./subsystem-BI_9bRVk.js";
import "./exec-DrVRn_Jz.js";
import "./model-selection-BplWstrh.js";
import "./github-copilot-token-nncItI8D.js";
import { r as resolveCliName, t as formatCliCommand } from "./command-format-ChfKqObn.js";
import "./boolean-BgXe2hyu.js";
import "./env-C-qlQMcy.js";
import "./host-env-security-ljCLeQmh.js";
import "./message-channel-CNKATuOe.js";
import "./send-DC_gnWl7.js";
import "./config-B-zigsOM.js";
import "./env-vars-CvvqezS9.js";
import "./manifest-registry-DmfPU4rc.js";
import "./dock-pv6HNE8P.js";
import "./runner-DlkDtGMF.js";
import "./image-BnuhI2Cj.js";
import "./models-config-Cyvd_XlY.js";
import "./pi-model-discovery-Bakt-Qrp.js";
import "./pi-embedded-helpers-CYkXMKVk.js";
import "./sandbox-Cj9__aI8.js";
import "./tool-catalog-CrsxKKLj.js";
import "./chrome-BRkMDdSw.js";
import "./tailscale-BSqgz1Js.js";
import "./ip-D0zgNmBV.js";
import "./tailnet-CEudzG0i.js";
import "./ws-BTdBA7Dw.js";
import "./auth-BD8Ix8PK.js";
import "./server-context-Cur9z9vt.js";
import "./frontmatter-DR47FZL2.js";
import "./skills-CCMjt8qH.js";
import "./redact-CsoNhWtr.js";
import "./errors-Fe4Am7dY.js";
import "./fs-safe-DwCRJYoe.js";
import "./paths-BXdAEtPH.js";
import "./ssrf-D0C-ivqd.js";
import "./image-ops-CE-faKvL.js";
import "./store-BK1dfn-n.js";
import "./ports-3dBfxsrO.js";
import "./trash-D8z5X58K.js";
import "./server-middleware-BrDs7VpV.js";
import "./sessions-DqsLePIP.js";
import "./plugins-BinSBKMc.js";
import "./accounts-dnbnpwVy.js";
import "./accounts-v9OZODSg.js";
import "./accounts-CRMme1-m.js";
import "./bindings-ClBJqDjo.js";
import "./logging-6RmrnEvA.js";
import "./send-B_0OrRns.js";
import "./paths-DlJnj-kN.js";
import "./chat-envelope-BndZPORx.js";
import "./tool-images-D5OSqXNT.js";
import "./tool-display-C9bjmvg5.js";
import "./fetch-guard-dxO4wHd_.js";
import "./api-key-rotation-9GuRsDju.js";
import "./local-roots-C60e0qcm.js";
import "./query-expansion-DnHjuewR.js";
import "./model-catalog-DZqJvaPa.js";
import "./tokens-cSmVhS4T.js";
import "./deliver-CdP4kAhm.js";
import "./commands-x815aA4b.js";
import "./commands-registry-BSxy4DgA.js";
import "./pairing-store-DxSRfhPA.js";
import "./fetch-HC0TapP4.js";
import "./retry-DhFNEOmQ.js";
import "./client-DFzpvqcB.js";
import "./call-Ca3DeJSo.js";
import "./pairing-token-ME6zTwDj.js";
import "./exec-approvals-60bNO4M9.js";
import "./exec-approvals-allowlist-C-wqAKbm.js";
import "./exec-safe-bin-runtime-policy-DphNNorC.js";
import "./nodes-screen-fVbM2cN7.js";
import "./target-errors-CYwiezmi.js";
import "./diagnostic-session-state-SaJqT4ri.js";
import "./with-timeout-B1gAmQeQ.js";
import "./diagnostic-RiNhxqE9.js";
import "./send-B-QL3Maf.js";
import "./model-7KBHDDZc.js";
import "./reply-prefix-5xu-ppj6.js";
import "./memory-cli-DXxJ98UL.js";
import "./manager-U4h8roY4.js";
import "./chunk-CpcwNHjN.js";
import "./markdown-tables-BfSWMf3M.js";
import "./ir-N7XSDxlP.js";
import "./render-JkHfM4BD.js";
import "./channel-activity-GY5H5R7T.js";
import "./tables-CRO4iaNb.js";
import "./send-YwvW8w1D.js";
import "./proxy-W7lEAcDj.js";
import "./links-DAjZnzLs.js";
import "./cli-utils-DK6017OO.js";
import "./help-format-UE3NC3_c.js";
import "./progress-D9e-_5R1.js";
import "./resolve-route-DcNxLgKf.js";
import "./pi-tools.policy-Y3MzHcBa.js";
import "./replies-DVonfCs7.js";
import "./skill-commands-C8lbexww.js";
import "./workspace-dirs-C_qqC6-T.js";
import "./plugin-auto-enable-fSLOH4tB.js";
import "./channel-selection-CzvWLasv.js";
import "./outbound-attachment-Bx4qvyPz.js";
import "./delivery-queue-CUHuw1Sc.js";
import "./session-cost-usage-uoPEmNk1.js";
import "./send-C5tDSWnl.js";
import { b as waitForGatewayReachable, f as openUrl, g as resolveControlUiLinks, i as detectBrowserOpenSupport, m as probeGatewayReachable, o as formatControlUiSshHint } from "./onboard-helpers-BWT9XK6x.js";
import "./prompt-style-D3Nh-ono.js";
import "./pairing-labels-BnyqFGCm.js";
import "./server-lifecycle-xThr9fdy.js";
import "./stagger-CPIlBwxt.js";
import "./runtime-guard-DSWGxN2k.js";
import "./program-context-C3pFmHy4.js";
import "./note-hhvlGJif.js";
import { r as installCompletion } from "./completion-cli-D7Kf01CG.js";
import { n as gatewayInstallErrorHint, t as buildGatewayInstallPlan } from "./daemon-install-helpers-CHb1f0qx.js";
import { n as GATEWAY_DAEMON_RUNTIME_OPTIONS, t as DEFAULT_GATEWAY_DAEMON_RUNTIME } from "./daemon-runtime-D3e11yMG.js";
import { r as isSystemdUserServiceAvailable } from "./systemd-xGWqaz9t.js";
import { t as resolveGatewayService } from "./service-DNj2-Nul.js";
import { r as healthCommand } from "./health-BfYdRHB3.js";
import { t as ensureControlUiAssetsBuilt } from "./control-ui-assets-mmx2V6g4.js";
import { t as formatHealthCheckFailure } from "./health-format-Ci9zuYno.js";
import { r as ensureCompletionCacheExists, t as checkShellCompletionStatus } from "./doctor-completion-CdNDG77t.js";
import { t as runTui } from "./tui-BG2a7JOW.js";
import os from "node:os";
import path from "node:path";
import fs from "node:fs/promises";

//#region src/wizard/onboarding.completion.ts
async function resolveProfileHint(shell) {
	const home = process.env.HOME || os.homedir();
	if (shell === "zsh") return "~/.zshrc";
	if (shell === "bash") return await pathExists(path.join(home, ".bashrc")) ? "~/.bashrc" : "~/.bash_profile";
	if (shell === "fish") return "~/.config/fish/config.fish";
	return "$PROFILE";
}
function formatReloadHint(shell, profileHint) {
	if (shell === "powershell") return "Restart your shell (or reload your PowerShell profile).";
	return `Restart your shell or run: source ${profileHint}`;
}
async function setupOnboardingShellCompletion(params) {
	const deps = {
		resolveCliName,
		checkShellCompletionStatus,
		ensureCompletionCacheExists,
		installCompletion,
		...params.deps
	};
	const cliName = deps.resolveCliName();
	const completionStatus = await deps.checkShellCompletionStatus(cliName);
	if (completionStatus.usesSlowPattern) {
		if (await deps.ensureCompletionCacheExists(cliName)) await deps.installCompletion(completionStatus.shell, true, cliName);
		return;
	}
	if (completionStatus.profileInstalled && !completionStatus.cacheExists) {
		await deps.ensureCompletionCacheExists(cliName);
		return;
	}
	if (!completionStatus.profileInstalled) {
		if (!(params.flow === "quickstart" ? true : await params.prompter.confirm({
			message: `Enable ${completionStatus.shell} shell completion for ${cliName}?`,
			initialValue: true
		}))) return;
		if (!await deps.ensureCompletionCacheExists(cliName)) {
			await params.prompter.note(`Failed to generate completion cache. Run \`${cliName} completion --install\` later.`, "Shell completion");
			return;
		}
		await deps.installCompletion(completionStatus.shell, true, cliName);
		const profileHint = await resolveProfileHint(completionStatus.shell);
		await params.prompter.note(`Shell completion installed. ${formatReloadHint(completionStatus.shell, profileHint)}`, "Shell completion");
	}
}

//#endregion
//#region src/wizard/onboarding.finalize.ts
async function finalizeOnboardingWizard(options) {
	const { flow, opts, baseConfig, nextConfig, settings, prompter, runtime } = options;
	const withWizardProgress = async (label, options, work) => {
		const progress = prompter.progress(label);
		try {
			return await work(progress);
		} finally {
			progress.stop(options.doneMessage);
		}
	};
	const systemdAvailable = process.platform === "linux" ? await isSystemdUserServiceAvailable() : true;
	if (process.platform === "linux" && !systemdAvailable) await prompter.note("Systemd user services are unavailable. Skipping lingering checks and service install.", "Systemd");
	if (process.platform === "linux" && systemdAvailable) {
		const { ensureSystemdUserLingerInteractive } = await import("./systemd-linger-C1BEa8ei.js").then((n) => n.r);
		await ensureSystemdUserLingerInteractive({
			runtime,
			prompter: {
				confirm: prompter.confirm,
				note: prompter.note
			},
			reason: "Linux installs use a systemd user service by default. Without lingering, systemd stops the user session on logout/idle and kills the Gateway.",
			requireConfirm: false
		});
	}
	const explicitInstallDaemon = typeof opts.installDaemon === "boolean" ? opts.installDaemon : void 0;
	let installDaemon;
	if (explicitInstallDaemon !== void 0) installDaemon = explicitInstallDaemon;
	else if (process.platform === "linux" && !systemdAvailable) installDaemon = false;
	else if (flow === "quickstart") installDaemon = true;
	else installDaemon = await prompter.confirm({
		message: "Install Gateway service (recommended)",
		initialValue: true
	});
	if (process.platform === "linux" && !systemdAvailable && installDaemon) {
		await prompter.note("Systemd user services are unavailable; skipping service install. Use your container supervisor or `docker compose up -d`.", "Gateway service");
		installDaemon = false;
	}
	if (installDaemon) {
		const daemonRuntime = flow === "quickstart" ? DEFAULT_GATEWAY_DAEMON_RUNTIME : await prompter.select({
			message: "Gateway service runtime",
			options: GATEWAY_DAEMON_RUNTIME_OPTIONS,
			initialValue: opts.daemonRuntime ?? DEFAULT_GATEWAY_DAEMON_RUNTIME
		});
		if (flow === "quickstart") await prompter.note("QuickStart uses Node for the Gateway service (stable + supported).", "Gateway service runtime");
		const service = resolveGatewayService();
		const loaded = await service.isLoaded({ env: process.env });
		if (loaded) {
			const action = await prompter.select({
				message: "Gateway service already installed",
				options: [
					{
						value: "restart",
						label: "Restart"
					},
					{
						value: "reinstall",
						label: "Reinstall"
					},
					{
						value: "skip",
						label: "Skip"
					}
				]
			});
			if (action === "restart") await withWizardProgress("Gateway service", { doneMessage: "Gateway service restarted." }, async (progress) => {
				progress.update("Restarting Gateway service…");
				await service.restart({
					env: process.env,
					stdout: process.stdout
				});
			});
			else if (action === "reinstall") await withWizardProgress("Gateway service", { doneMessage: "Gateway service uninstalled." }, async (progress) => {
				progress.update("Uninstalling Gateway service…");
				await service.uninstall({
					env: process.env,
					stdout: process.stdout
				});
			});
		}
		if (!loaded || loaded && !await service.isLoaded({ env: process.env })) {
			const progress = prompter.progress("Gateway service");
			let installError = null;
			try {
				progress.update("Preparing Gateway service…");
				const { programArguments, workingDirectory, environment } = await buildGatewayInstallPlan({
					env: process.env,
					port: settings.port,
					token: settings.gatewayToken,
					runtime: daemonRuntime,
					warn: (message, title) => prompter.note(message, title),
					config: nextConfig
				});
				progress.update("Installing Gateway service…");
				await service.install({
					env: process.env,
					stdout: process.stdout,
					programArguments,
					workingDirectory,
					environment
				});
			} catch (err) {
				installError = err instanceof Error ? err.message : String(err);
			} finally {
				progress.stop(installError ? "Gateway service install failed." : "Gateway service installed.");
			}
			if (installError) {
				await prompter.note(`Gateway service install failed: ${installError}`, "Gateway");
				await prompter.note(gatewayInstallErrorHint(), "Gateway");
			}
		}
	}
	if (!opts.skipHealth) {
		await waitForGatewayReachable({
			url: resolveControlUiLinks({
				bind: nextConfig.gateway?.bind ?? "loopback",
				port: settings.port,
				customBindHost: nextConfig.gateway?.customBindHost,
				basePath: void 0
			}).wsUrl,
			token: settings.gatewayToken,
			deadlineMs: 15e3
		});
		try {
			await healthCommand({
				json: false,
				timeoutMs: 1e4
			}, runtime);
		} catch (err) {
			runtime.error(formatHealthCheckFailure(err));
			await prompter.note([
				"Docs:",
				"https://docs.openclaw.ai/gateway/health",
				"https://docs.openclaw.ai/gateway/troubleshooting"
			].join("\n"), "Health check help");
		}
	}
	const controlUiEnabled = nextConfig.gateway?.controlUi?.enabled ?? baseConfig.gateway?.controlUi?.enabled ?? true;
	if (!opts.skipUi && controlUiEnabled) {
		const controlUiAssets = await ensureControlUiAssetsBuilt(runtime);
		if (!controlUiAssets.ok && controlUiAssets.message) runtime.error(controlUiAssets.message);
	}
	await prompter.note([
		"Add nodes for extra features:",
		"- macOS app (system + notifications)",
		"- iOS app (camera/canvas)",
		"- Android app (camera/canvas)"
	].join("\n"), "Optional apps");
	const controlUiBasePath = nextConfig.gateway?.controlUi?.basePath ?? baseConfig.gateway?.controlUi?.basePath;
	const links = resolveControlUiLinks({
		bind: settings.bind,
		port: settings.port,
		customBindHost: settings.customBindHost,
		basePath: controlUiBasePath
	});
	const authedUrl = settings.authMode === "token" && settings.gatewayToken ? `${links.httpUrl}#token=${encodeURIComponent(settings.gatewayToken)}` : links.httpUrl;
	const gatewayProbe = await probeGatewayReachable({
		url: links.wsUrl,
		token: settings.authMode === "token" ? settings.gatewayToken : void 0,
		password: settings.authMode === "password" ? nextConfig.gateway?.auth?.password : ""
	});
	const gatewayStatusLine = gatewayProbe.ok ? "Gateway: reachable" : `Gateway: not detected${gatewayProbe.detail ? ` (${gatewayProbe.detail})` : ""}`;
	const bootstrapPath = path.join(resolveUserPath(options.workspaceDir), DEFAULT_BOOTSTRAP_FILENAME);
	const hasBootstrap = await fs.access(bootstrapPath).then(() => true).catch(() => false);
	await prompter.note([
		`Web UI: ${links.httpUrl}`,
		settings.authMode === "token" && settings.gatewayToken ? `Web UI (with token): ${authedUrl}` : void 0,
		`Gateway WS: ${links.wsUrl}`,
		gatewayStatusLine,
		"Docs: https://docs.openclaw.ai/web/control-ui"
	].filter(Boolean).join("\n"), "Control UI");
	let controlUiOpened = false;
	let controlUiOpenHint;
	let hatchChoice = null;
	let launchedTui = false;
	if (!opts.skipUi && gatewayProbe.ok) {
		if (hasBootstrap) await prompter.note([
			"This is the defining action that makes your agent you.",
			"Please take your time.",
			"The more you tell it, the better the experience will be.",
			"We will send: \"Wake up, my friend!\""
		].join("\n"), "Start TUI (best option!)");
		await prompter.note([
			"Gateway token: shared auth for the Gateway + Control UI.",
			"Stored in: ~/.openclaw/openclaw.json (gateway.auth.token) or OPENCLAW_GATEWAY_TOKEN.",
			`View token: ${formatCliCommand("openclaw config get gateway.auth.token")}`,
			`Generate token: ${formatCliCommand("openclaw doctor --generate-gateway-token")}`,
			"Web UI stores a copy in this browser's localStorage (openclaw.control.settings.v1).",
			`Open the dashboard anytime: ${formatCliCommand("openclaw dashboard --no-open")}`,
			"If prompted: paste the token into Control UI settings (or use the tokenized dashboard URL)."
		].join("\n"), "Token");
		hatchChoice = await prompter.select({
			message: "How do you want to hatch your bot?",
			options: [
				{
					value: "tui",
					label: "Hatch in TUI (recommended)"
				},
				{
					value: "web",
					label: "Open the Web UI"
				},
				{
					value: "later",
					label: "Do this later"
				}
			],
			initialValue: "tui"
		});
		if (hatchChoice === "tui") {
			restoreTerminalState("pre-onboarding tui", { resumeStdinIfPaused: true });
			await runTui({
				url: links.wsUrl,
				token: settings.authMode === "token" ? settings.gatewayToken : void 0,
				password: settings.authMode === "password" ? nextConfig.gateway?.auth?.password : "",
				deliver: false,
				message: hasBootstrap ? "Wake up, my friend!" : void 0
			});
			launchedTui = true;
		} else if (hatchChoice === "web") {
			if ((await detectBrowserOpenSupport()).ok) {
				controlUiOpened = await openUrl(authedUrl);
				if (!controlUiOpened) controlUiOpenHint = formatControlUiSshHint({
					port: settings.port,
					basePath: controlUiBasePath,
					token: settings.authMode === "token" ? settings.gatewayToken : void 0
				});
			} else controlUiOpenHint = formatControlUiSshHint({
				port: settings.port,
				basePath: controlUiBasePath,
				token: settings.authMode === "token" ? settings.gatewayToken : void 0
			});
			await prompter.note([
				`Dashboard link (with token): ${authedUrl}`,
				controlUiOpened ? "Opened in your browser. Keep that tab to control OpenClaw." : "Copy/paste this URL in a browser on this machine to control OpenClaw.",
				controlUiOpenHint
			].filter(Boolean).join("\n"), "Dashboard ready");
		} else await prompter.note(`When you're ready: ${formatCliCommand("openclaw dashboard --no-open")}`, "Later");
	} else if (opts.skipUi) await prompter.note("Skipping Control UI/TUI prompts.", "Control UI");
	await prompter.note(["Back up your agent workspace.", "Docs: https://docs.openclaw.ai/concepts/agent-workspace"].join("\n"), "Workspace backup");
	await prompter.note("Running agents on your computer is risky — harden your setup: https://docs.openclaw.ai/security", "Security");
	await setupOnboardingShellCompletion({
		flow,
		prompter
	});
	if (!opts.skipUi && settings.authMode === "token" && Boolean(settings.gatewayToken) && hatchChoice === null) {
		if ((await detectBrowserOpenSupport()).ok) {
			controlUiOpened = await openUrl(authedUrl);
			if (!controlUiOpened) controlUiOpenHint = formatControlUiSshHint({
				port: settings.port,
				basePath: controlUiBasePath,
				token: settings.gatewayToken
			});
		} else controlUiOpenHint = formatControlUiSshHint({
			port: settings.port,
			basePath: controlUiBasePath,
			token: settings.gatewayToken
		});
		await prompter.note([
			`Dashboard link (with token): ${authedUrl}`,
			controlUiOpened ? "Opened in your browser. Keep that tab to control OpenClaw." : "Copy/paste this URL in a browser on this machine to control OpenClaw.",
			controlUiOpenHint
		].filter(Boolean).join("\n"), "Dashboard ready");
	}
	const webSearchKey = (nextConfig.tools?.web?.search?.apiKey ?? "").trim();
	const webSearchEnv = (process.env.BRAVE_API_KEY ?? "").trim();
	const hasWebSearchKey = Boolean(webSearchKey || webSearchEnv);
	await prompter.note(hasWebSearchKey ? [
		"Web search is enabled, so your agent can look things up online when needed.",
		"",
		webSearchKey ? "API key: stored in config (tools.web.search.apiKey)." : "API key: provided via BRAVE_API_KEY env var (Gateway environment).",
		"Docs: https://docs.openclaw.ai/tools/web"
	].join("\n") : [
		"If you want your agent to be able to search the web, you’ll need an API key.",
		"",
		"OpenClaw uses Brave Search for the `web_search` tool. Without a Brave Search API key, web search won’t work.",
		"",
		"Set it up interactively:",
		`- Run: ${formatCliCommand("openclaw configure --section web")}`,
		"- Enable web_search and paste your Brave Search API key",
		"",
		"Alternative: set BRAVE_API_KEY in the Gateway environment (no config changes).",
		"Docs: https://docs.openclaw.ai/tools/web"
	].join("\n"), "Web search (optional)");
	await prompter.note("What now: https://openclaw.ai/showcase (\"What People Are Building\").", "What now");
	await prompter.outro(controlUiOpened ? "Onboarding complete. Dashboard opened; keep that tab to control OpenClaw." : "Onboarding complete. Use the dashboard link above to control OpenClaw.");
	return { launchedTui };
}

//#endregion
export { finalizeOnboardingWizard };